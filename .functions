#!/bin/bash

# Utility function to check if $1 command exists
# Use example: if exists ls; then echo "Command exists!"; else echo "Command does not exist."; fi
function exists() {
  command -v $1 >/dev/null 2>&1 && { return 0; } || { return 1; }
}

# Try to make clipboard available
if ! [[ "$OSTYPE" =~ ^darwin ]]; then
  # Not on a Mac. If available, use xclip or xsel instead of pbcopy/pbpaste
  if exists xsel; then 
    alias pbcopy='xsel --clipboard --input'
    alias pbpaste='xsel --clipboard --output'
  else 
    if exists xclip; then
      alias pbcopy='xclip -selection clipboard'
      alias pbpaste='xclip -selection clipboard -o'
    else 
      echo "Could not find a viable alternative to pbcopy/pbpaste.";
    fi
  fi
fi

# Create a new directory and enter it
function md() {
  mkdir -p "$@" && cd "$@"
}

# List after cd
function cx() {
  cd "$1";
  la
}

# find shorthand
function f() {
  find . -name "$1"
}

# On Mac, cd into whatever is the forefront Finder window.
function cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# List recursively from working directory using less. Don't use in ~
# http://stackoverflow.com/a/1767559
function lr() {
  ls -R `pwd` | awk '/:$/&&f{s=$0;f=0}/:$/&&!f{sub(/:$/,"");s=$0;f=1;next}NF&&f{ print s"/"$0 }' | more
}

# Display a file tree from current directory
# From http://www.bashoneliners.com/main/oneliner/157/
function lst() {
  ls -Ra | grep ":$" | sed -e 's/:$//' -e 's/[^-][^\/]*\//--/g' -e 's/^/   /' -e 's/-/|/'
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}"
  open "http://localhost:${port}/"
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# git log with per-commit cmd-clickable GitHub URLs (iTerm)
function gl() {
  local remote="$(git remote -v | awk '/^origin.*\(push\)$/ {print $2}')"
  [[ "$remote" ]] || return
  local user_repo="$(echo "$remote" | perl -pe 's/.*://;s/\.git$//')"
  git log $* --name-status --color | awk "$(cat <<AWK
    /^.*commit [0-9a-f]{40}/ {sha=substr(\$2,1,7)}
    /^[MA]\t/ {printf "%s\thttps://github.com/$user_repo/blob/%s/%s\n", \$1, sha, \$2; next}
    /.*/ {print \$0}
AWK
  )" | less -F
}

# Copy w/ progress
function cp_p() {
  rsync -WavP --human-readable --progress $1 $2
}

# Copy file path to clipboard
# Includes argument if given
function get_path() {
  ##echo "$PWD/$*" | pbcopy
  printf "%s/%s" $(printf "$PWD" | tr -d "\n") $(printf "${1}" | tr -d "\n") | pbcopy
} 

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcomp() {
  encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Syntax-highlight JSON strings or files
function json() {
  if [ -p /dev/stdin ]; then
    # piping, e.g. `echo '{"foo":42}' | json`
    python -mjson.tool | pygmentize -l javascript
  else
    # e.g. `json '{"foo":42}'`
    python -mjson.tool <<< "$*" | pygmentize -l javascript
  fi
}

# get gzipped size
function gz() {
  local origsize=$(wc -c < "$1")
  local gzipsize=$(gzip -c "$1" | wc -c)
  local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
  printf "orig: %d bytes\n" "$origsize"
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
  echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
  echo # newline
}

# Extract archives - use: extract <file>
# Credits to http://dotfiles.org/~pseup/.bashrc
function xt() {
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2) tar xjf $1 ;;
      *.tar.gz) tar xzf $1 ;;
      *.bz2) bunzip2 $1 ;;
      *.rar) rar x $1 ;;
      *.gz) gunzip $1 ;;
      *.tar) tar xf $1 ;;
      *.tbz2) tar xjf $1 ;;
      *.tgz) tar xzf $1 ;;
      *.zip) unzip $1 ;;
      *.Z) uncompress $1 ;;
      *.7z) 7z x $1 ;;
      *) echo "'$1' cannot be extracted via extract()" ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Simple calculator
function calc() {
  local result=""
  result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
  #                       └─ default (when `--mathlib` is used) is 20
  #
  if [[ "$result" == *.* ]]; then
    # improve the output for decimal numbers
    printf "$result" |
    sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
        -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
        -e 's/0*$//;s/\.$//'   # remove trailing zeros
  else
    printf "$result"
  fi
  printf "\n"
}

# Find out the previous and the nextcoming value of number according to golden ratio
function phind() {
  local lower=""
  local higher=""
  local even_lower=""
  local even_higher=""
  higher="$(echo $1*phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"
  lower="$(echo $1/phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"
  even_higher="$(echo $higher*phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"
  even_lower="$(echo $lower/phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"

  printf "$even_lower  $lower  [$1]  $higher  $even_higher\n"
}

# Refresh bash profile
function r() {
  echo "Reloading profile..."
  source "$HOME/.bash_profile"
  echo "Done."
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

# Grep shorthand 
function gr() {
  grep -nRHIi "$1" .
}

# Check a url every 10 seconds until it returns 200 OK
function ask(){
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}ask${RESET} <url> [ <interval in seconds> ]\n"
    printf "Check url every 10 seconds until it returns 200 OK. Second parameter is optional and changes the interval.\n"
    return 1
  fi
  if ! [[ "$2" =~ ^[0-9]+$ ]]; then
    delay=10
  else
    delay="$2"
  fi
  printf "\n%s ${ORANGE}%s${RESET} every ${YELLOW}%s${RESET} seconds\n" "Querying" $1 $delay
  printf "Quit with ${BOLD}${GREEN}CTRL+C${RESET}\n"
  until curl -s --head $1 | grep "200 OK" > /dev/null; do
      printf "${ORANGE}%s${RESET}" "."
      sleep $delay
  done
  printf "\nURL $1 returned a 200 OK on `date`\n"
}

# Download website $1 to folder $2
function mirror() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}mirror${RESET} <url to download> <destination folder>\n"
    printf "Tries to create a local mirror of a site and offers to serve it on complete.\n"
    return 1
  fi
  echo Downloading url \'$1\' to folder \'$2\'
  # Good to know:
  # http://www.ibm.com/developerworks/linux/library/l-bash2/index.html
  wget --user-agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31" --mirror -p --convert-links -P ./$2 $1 && echo -e "\nDone."
  fldr=$(echo $1 | awk -F/ '{print $3}')
  cd $2/$fldr && la && read -p "Serve this folder? Enter port number or 0 to exit. "
  echo
  if [[ "$REPLY" > 0 ]]; then
    server $REPLY
  else 
    echo "Done."
    return
  fi
}

# Kill all processes listening on specified port (Beware this will also kill browsers etc)
function killport() {
  local port="${1:-8000}"
  lsof -i tcp:${port} | awk 'NR!=1 {print $2}' | xargs kill 
}

function mgnt() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}mgnt${RESET} <full magnet: link>\n"
    printf "Starts download from magnet: link using aria2. Executes ${BOLD}~/.aria_done${RESET} on complete.\n"
    return 1
  fi
  aria2c --dir=$DOWNLOADS_FOLDER --quiet=true --on-bt-download-complete=$HOME/.aria_done "$1" &
}

# Replace word $1 with word $2 in files with names 
# matching "*.$3" in current folder
function snr() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}snr${RESET} <word to find> <word to substitute> <file extension>\n"
    return 1
  fi
  # $1 find this
  # $2 replace with this
  # $3 file extension
    echo -e "Replacing '$1' with '$2' in all files matching '*.$3' in current folder."
    read -p "Continue? (y/n) "
    if [[ "$REPLY" == "y" ]]; then
      find . -name "*.$3" -type f -exec sed -i '' "s/$(echo $1 | sed -e 's/[\/&]/\\&/g')/$(echo $2 | sed -e 's/[\/&]/\\&/g')/g" {} +
    else 
      echo "Aborting."
    fi
}

# Shortcut to time tracker
# http://tim.thechases.com/bvi/tt.py
function t(){
  if [[ "$1" == "fullhelp" ]]; then
    cat ~/bin/tt/fullhelp.txt | more
  else
    python ~/bin/tt/tt.py "$@"
  fi
}

# Print out images in console as ascii
function primg() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}primg${RESET} <path/to/file/> [ <--force> ]\n"
    printf "Attempts to print out an image file as ascii using asciiart or jp2a (using ImageMagick's ${BOLD}convert${RESET}).\n"
    echo -e "The optional --force option send any file through convert, might cause errors or unexpected behavior.\n"
    return 1
  fi
  width=$((COLUMNS-2))
  file=$1

  if exists asciiart && [ -z "$2" ]; then
    asciiart -w $width -c -i $file
  else
    # We don't have asciiart, check for jp2a
    if exists jp2a; then
      # Success! Set some common options. If you use a light background, change --background appropriately
      opts="--width=$width --background=dark --colors"
      # Since jp2a only takes jpgs as input, we need to pipe through ImageMagick's convert
      if exists convert; then
        pipe_through="convert -resize ${width}x -contrast -contrast -quiet $file jpg:-"
      else
        # Exit unsuccesfully if convert doesn't exist
        echo "Couldn't convert image, exiting."; return 1
      fi
      # Check file format. If --force is set just send it through convert without caring about file types.
      if [ -f $file ]; then
        # Check if force option is set
        if [ "$2" == "--force" ] || [ "$2" == "-f" ]; then
          echo -e "Forcing convert.\n"
          command $pipe_through | jp2a $opts - $file 2>/dev/null
        else
          case $file in
            *.jpg)
              command jp2a $opts $file
              ;;
            *.gif|*.png|*.bmp|*.ico|*.pdf|*.svg|*.ai|*.tiff)
              command $pipe_through | jp2a $opts - $file 2>/dev/null
              ;;
            *)
              # Not one of the extensions listed above, but probably supported by IM still.
              # Advice user about the --force option
              echo "Couldn't print image, '$file', unsupported image file."
              ;;
          esac
        fi
      else
        echo "Couldn't print image, '$file' is not a valid file"
      fi
    else
      # Sorry, couldn't find the right software
      echo "Couldn't print image, no conversion software found. Try installing 'asciiart' or 'jp2a'."; return 1
    fi
  fi
}

function cdp() {
  if [[ -z "$1" ]]; then
    if [ "$VIRTUAL_ENV" != "" ]; then
      deactivate
    fi
    return
  fi

  if [[ -z "$PROJECT_FOLDER" ]]; then
    echo "You have not set your project folder in .extras. Exiting."
    return 1
  else
    for folder in $PROJECT_FOLDER/{"$1"/src/"$1","$1"/"$1","$1"}; do
      if [[ -d "$folder" ]]; then
        cd $folder
        echo -e "Found project folder: $folder."
        break
      fi
    done
    unset folder

    if [ -e ~/.virtualenvs/$1/bin/activate ]; then
      workon $1
      . $HOME/.bash_profile && clear
      echo -e "Project ${YELLOW}$1${RESET} activated."
    fi
  fi
}