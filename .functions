#!/bin/bash

# Utility function to check if $1 command exists
# Use example: if exists ls; then echo "Command exists."; else echo "Command does not exist."; fi
function exists() {
  cmnd=${1:?"Please supply a command to look for."}
  command -v $cmnd >/dev/null 2>&1 && { return 0; } || { return 1; }
}

# Try to make clipboard available
if ! [[ "$OSTYPE" =~ ^darwin ]]; then
  # Not on a Mac. If available, use xclip or xsel instead of pbcopy/pbpaste
  if exists xsel; then 
    alias pbcopy='xsel --clipboard --input'
    alias pbpaste='xsel --clipboard --output'
  else 
    if exists xclip; then
      alias pbcopy='xclip -selection clipboard'
      alias pbpaste='xclip -selection clipboard -o'
    else 
      echo "Could not find a viable alternative to pbcopy/pbpaste. Try installing xsel or xclip.";
    fi
  fi
fi

# Create a new directory and enter it
function md() {
  mkdir -p "$@" && cd "$@"
}

# find shorthand
function f() {
  find . -name "$1"
}

# On Mac, cd into whatever is the forefront Finder window.
function cdf() {  # short for cdfinder
  cd "`osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)'`"
}

# List recursively from working directory using less. Don't use in ~
# http://stackoverflow.com/a/1767559
function lr() {
  ls -R `pwd` | awk '/:$/&&f{s=$0;f=0}/:$/&&!f{sub(/:$/,"");s=$0;f=1;next}NF&&f{ print s"/"$0 }' | more
}

# Display a file tree from current directory
# From http://www.bashoneliners.com/main/oneliner/157/
function lst() {
  ls -Ra | grep ":$" | sed -e 's/:$//' -e 's/[^-][^\/]*\//--/g' -e 's/^/   /' -e 's/-/|/'
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
  local port="${1:-8000}"
  open "http://localhost:${port}/"
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# git log with per-commit cmd-clickable GitHub URLs (iTerm)
function gl() {
  local remote="$(git remote -v | awk '/^origin.*\(push\)$/ {print $2}')"
  [[ "$remote" ]] || return
  local user_repo="$(echo "$remote" | perl -pe 's/.*://;s/\.git$//')"
  git log $* --name-status --color | awk "$(cat <<AWK
    /^.*commit [0-9a-f]{40}/ {sha=substr(\$2,1,7)}
    /^[MA]\t/ {printf "%s\thttps://github.com/$user_repo/blob/%s/%s\n", \$1, sha, \$2; next}
    /.*/ {print \$0}
AWK
  )" | less -F
}

# Copy w/ progress
function cp_p() {
  rsync -WavP --human-readable --progress $1 $2
}

# Copy file path to clipboard
# Includes argument if given (good w/ tab completion for getting path of specific file)
function gpath() {
  # Print to clipboard if possible
  if exists pbcopy; then
    printf "%s/%s" $(printf "$PWD" | tr -d "\n") $(printf "${1}" | tr -d "\n") | pbcopy
  else
    printf "%s/%s\n" $(printf "$PWD" | tr -d "\n") $(printf "${1}" | tr -d "\n")
  fi
} 

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcomp() {
  encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Syntax-highlight JSON strings or files
function json() {
  if [ -p /dev/stdin ]; then
    # piping, e.g. `echo '{"foo":42}' | json`
    python -mjson.tool | pygmentize -l javascript -O style=monokai -f console256
  else
    # e.g. `json '{"foo":42}'`
    python -mjson.tool <<< "$*" | pygmentize -l javascript -O style=monokai -f console256
  fi
}

# get gzipped size
function gz() {
  local origsize=$(wc -c < "$1")
  local gzipsize=$(gzip -c "$1" | wc -c)
  local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
  printf "orig: %d bytes\n" "$origsize"
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
  echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
  echo # newline
}

# Extract archives - use: xt <file>
# Credits to http://dotfiles.org/~pseup/.bashrc
function xt() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}xt${RESET} <archive to extract>\n"
    printf "Tries to extract an archive based on file extension.\n"
    printf "\n"
    return 1
  fi
  local error="'$1' cannot be extracted via xt"
  if [ -f $1 ] ; then
    case $1 in
      *.tar.bz2) tar xjf $1 ;;
      *.tar.gz) tar xzf $1 ;;
      *.bz2) bunzip2 $1 ;;
      *.rar)
        if ( exists rar ) ; then 
          rar x $1
        elif ( exists unrar ) ; then 
          unrar x $1
        else
          echo $error
        fi
      ;;
      *.gz) gunzip $1 ;;
      *.tar) tar xf $1 ;;
      *.tbz2) tar xjf $1 ;;
      *.tgz) tar xzf $1 ;;
      *.zip) unzip $1 ;;
      *.Z) uncompress $1 ;;
      *.7z) 7z x $1 ;;
      *) echo $error ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

# Simple calculator
function calc() {
  local result=""
  result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
  #                       └─ default (when `--mathlib` is used) is 20
  #
  if [[ "$result" == *.* ]]; then
    # improve the output for decimal numbers
    printf "$result" |
    sed -e 's/^\./0./'        `# add "0" for cases like ".5"` \
        -e 's/^-\./-0./'      `# add "0" for cases like "-.5"`\
        -e 's/0*$//;s/\.$//'   # remove trailing zeros
  else
    printf "$result"
  fi
  printf "\n"
}

# Find out the previous and the nextcoming value of number according to golden ratio
function phind() {
  local lower=""
  local higher=""
  local even_lower=""
  local even_higher=""
  higher="$(echo $1*phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"
  lower="$(echo $1/phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"
  even_higher="$(echo $higher*phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"
  even_lower="$(echo $lower/phi | bc -l $HOME/.bc | tr -d '\\\n' | xargs printf '%.4f')"

  printf "$even_lower  $lower  [$1]  $higher  $even_higher\n"
}

# Refresh bash profile
function r() {
  echo "Reloading profile..."
  source "$HOME/.bash_profile"
  echo "Done."
}

# Determine size of a file or total size of a directory
function fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

# Grep shorthand 
function gr() {
  grep -nRHIi "$1" .
}

# Check a url every 10 seconds until it returns 200 OK
function ask(){
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}ask${RESET} <url> [ <interval in seconds> ]\n"
    printf "Check url every 10 seconds until it returns 200 OK. Second parameter is optional and changes the interval.\n"
    return 1
  fi
  if ! [[ "$2" =~ ^[0-9]+$ ]]; then
    delay=10
  else
    delay="$2"
  fi
  printf "\n%s ${ORANGE}%s${RESET} every ${YELLOW}%s${RESET} seconds\n" "Querying" $1 $delay
  printf "Quit with ${BOLD}${GREEN}CTRL+C${RESET}\n"
  until curl -s --head $1 | grep "200 OK" > /dev/null; do
      printf "${ORANGE}%s${RESET}" "."
      sleep $delay
  done
  printf "\nURL $1 returned a 200 OK on `date`\n"
}

# Download website $1 to folder $2
function mirror() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}mirror${RESET} <url to download> <destination folder> [ <username> <password> ]\n"
    printf "Tries to create a local mirror of a site and offers to serve it on complete.\n"
    printf "Optional arguments are for sites using basic authentication.\n"
    return 1
  fi
  echo Downloading url \'$1\' to folder \'$2\'

  # Do we have username/password?
  if [ "$#" -eq 4 ]; then
    echo Using basic authentication: $3/$4
    local un="--user=$3"
    local pw="--password=$4"
  fi

  wget --user-agent="Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_3) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.43 Safari/537.31" -mpckPE -e robots=off -w 1 --random-wait --directory-prefix=$2 $un $pw $1 && echo -e "\nDone."
  #fldr=$(echo $1 | awk -F/ '{print $3}')
  # wget doesn't need http:// so we cant rely on that when getting the domain for the folder name.
  # Trying a different approach:
  fldr=$(echo $1 | sed 's/https*:\/\/\([^\/]*\).*/\1/g')
  # Other attempts saved for prosperity: fldr=${1#http[s?]://};fldr=${fldr%%/*} || fldr=$( echo ${1#http[s?]://} | awk -F/ '{print $1}' )
  # Cd into folder and offer to serve it:
  cd $2/$fldr && echo $PWD && ls -la && read -p "Serve this folder? Enter port number or 0 to exit. "
  echo
  if [[ "$REPLY" > 0 ]]; then
    server $REPLY
  else 
    echo "Done."
    return
  fi
}

# Kill all processes listening on specified port (Beware this might also kill browsers etc)
function killport() {
  local port="${1:-8000}"
  lsof -i tcp:${port} | awk 'NR!=1 {print $2}' | xargs kill 
}

function mgnt() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}mgnt${RESET} <full magnet: link>\n"
    printf "Starts download from magnet: link using aria2. Executes ${BOLD}~/.aria_done${RESET} on complete.\n"
    return 1
  fi
  aria2c --dir=$DOWNLOADS_FOLDER --quiet=true --on-bt-download-complete=$HOME/.aria_done "$1" &
}

function kapp() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}kapp${RESET} <port> [ <kbits> ]\n"
    printf "Puts a quick cap on specified port. The optional variable defaults to 680.\n"
    printf "Typical bandwidths: ${BOLD}GPRS${RESET}: ~100; ${BOLD}EDGE${RESET}: ~200; ${BOLD}3G${RESET}: ~300.\nRequires root and ${BOLD}ipfw${RESET}.\n"
    return 1
  fi
  if [ -z "$2" ]; then
    kbits="680Kbit/s"
  else
    kbits="${2}Kbit/s"
  fi
  sudo ipfw pipe 1 config bw $kbits >/dev/null 2>&1 && sudo ipfw add 1 pipe 1 src-port $1 >/dev/null 2>&1
  read -p "Capping port $1 to $kbits. Press any key to stop..." -n 1 -s
  printf "\nCap removed.\n"
  sudo ipfw delete 1
}

# Replace word $1 with word $2 in files with names 
# matching "$3" recursively from current folder
function snr() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}snr${RESET} <word to find> <word to substitute> \"<file matching pattern>\"\n"
    printf "Search and replace using ${BOLD}find${RESET} and ${BOLD}sed${RESET}.\n"
    printf "Before any actual replacing is done, you will be presented a list of affected lines\n"
    printf "for each matching files containing the word, and the opportunity to cancel or proceed.\n"
    return 1
  fi

  local fnd="$1"
  local sbt="$2"
  local pat="$3"

  printf "Replacing \'$fnd\' with \'$sbt\' in all files matching pattern \'$pat\' recursively from current folder.\n"
  printf "${BOLD}Matches${RESET}:\n"
  
  find . -name "$pat" -exec \
    awk -v bd="$BOLD" -v yw="$YELLOW" -v rt="$RESET" -v ul="$UNDERLINE" '
      BEGIN {
        mtchs = 0
      }
      /'$fnd'/ {
        # Print filename on first match 
        if ( mtchs == 0 ) {
          print ( ul FILENAME rt ":" );
        }
        # Color all matches yellow and add the number of matches to total count
        mtchs += gsub(/'$fnd'/, ( yw "'$fnd'" rt ), $0);
        # Print line with linenumber
        printf ( "%s %5d:%s %s\n", bd, FNR, rt, $0)
      }
      END {
        if ( mtchs > 0 ) {
          print ( mtchs (mtchs > 1 ? " matches" : " match") " in file " FILENAME ".\n" )
        }
      }' {} \;
  read -p "Continue? (y/n) " -n 1
  if [[ "$REPLY" == "y" ]]; then
    find . -name "$3" -type f -exec sed -i '' "s/$(echo $fnd | sed -e 's/[\/&]/\\&/g')/$(echo $sbt | sed -e 's/[\/&]/\\&/g')/g" {} +
  else 
    printf "\nAborting.\n"
  fi
}

# Shortcut to time tracker
# http://tim.thechases.com/bvi/tt.py
function t(){
  if [[ "$1" == "fullhelp" ]]; then
    cat ~/bin/tt/fullhelp.txt | more
  else
    python ~/bin/tt/tt.py "$@"
  fi
}

# Print out images in console as ascii
function primg() {
  if [ -z "$1" ]; then
    printf "Usage:\n${BOLD}primg${RESET} <path/to/file/> [ --force ]\n"
    printf "Attempts to print out an image file as ascii using asciiart or jp2a (using ImageMagick's ${BOLD}convert${RESET}).\n"
    echo -e "The optional --force option sends any file through convert and might cause errors or unexpected behavior.\n"
    return 1
  fi
  width=$((COLUMNS-2))
  file=$1

  if exists asciiart && [ -z "$2" ]; then
    asciiart -w $width -c -i $file
  else
    # We don't have asciiart, check for jp2a
    if exists jp2a; then
      # Success! Set some common options. If you use a light background, change --background appropriately
      opts="--width=$width --background=dark --colors"
      # Since jp2a only takes jpgs as input, we need to pipe through ImageMagick's convert
      if exists convert; then
        pipe_through="convert -resize ${width}x -contrast -contrast -quiet $file jpg:-"
      else
        # Exit unsuccesfully if convert doesn't exist
        echo "Couldn't convert image, exiting."; return 1
      fi
      # Check file format. If --force is set just send it through convert without caring about file types.
      if [ -f $file ]; then
        # Check if force option is set
        if [ "$2" == "--force" ] || [ "$2" == "-f" ]; then
          echo -e "Forcing convert.\n"
          command $pipe_through | jp2a $opts - $file 2>/dev/null
        else
          case $file in
            *.jpg)
              command jp2a $opts $file
              ;;
            *.gif|*.png|*.bmp|*.ico|*.pdf|*.svg|*.ai|*.tiff)
              command $pipe_through | jp2a $opts - $file 2>/dev/null
              ;;
            *)
              # Not one of the extensions listed above, but probably supported by IM still.
              # Advice user about the --force option
              echo "Couldn't print image, '$file', unsupported image file."
              ;;
          esac
        fi
      else
        echo "Couldn't print image, '$file' is not a valid file"
      fi
    else
      # Sorry, couldn't find the right software
      echo "Couldn't print image, no conversion software found. Try installing 'asciiart' or 'jp2a'."; return 1
    fi
  fi
}

# Find project folder, enter it and activate the corresponding virtual env
function cdp() {
  if [[ -z "$1" ]]; then
    if [ "$VIRTUAL_ENV" = "" ]; then
      printf "Usage:\n${BOLD}cdp${RESET} <project_name>\n"
      printf "Finds project folder, enters it and activates the corresponding ${BOLD}virtualenv${RESET}).\n"
    else
      deactivate
    fi
    return
  fi

  if [[ -z "$PROJECT_FOLDER" ]]; then
    echo "You have not set your project folder in .extras. Exiting."
    return 1
  else
    for folder in $PROJECT_FOLDER/{"$1"/src/"$1","$1"/"$1","$1"}; do
      if [[ -d "$folder" ]]; then
        cd $folder
        echo -e "Found project folder: $folder."
        break
      fi
    done
    unset folder

    if [ -e ~/.virtualenvs/$1/bin/activate ]; then
      workon $1
      . $HOME/.bash_profile && clear
      echo -e "Project ${YELLOW}$1${RESET} activated."
    fi
  fi
}

# Send a markdown formatted file to lynx as html
function mdx() {
  if [[ -z "$1" ]]; then
      printf "Usage:\n${BOLD}mdx${RESET} <path/to/file> [ --dump ]\n"
      printf "Renders a markdown formatted file as HTML and pipes it to ${BOLD}lynx${RESET}).\n"
      printf "The optional --dump sends the output straight to stdout.\n"
  else
    if exists markdown; then 
      if [ "$2" == "--dump" ] || [ "$2" == "-d" ]; then
        local dump="-dump"
      fi
      markdown "$1" | lynx -stdin $dump
    else
      # Sorry, couldn't find the right software
      echo "Couldn't convert markdown. Get 'Markdown.pl' from: http://daringfireball.net/projects/markdown/"; return 1
    fi
  fi
}